import Head from "next/head";
import JishoAPI from "unofficial-jisho-api";
import { JishoAPIResult, JishoResult, KanjiParseResult  } from "unofficial-jisho-api";

import {
  Container,
  Main,
  Title,
  Description,
  CodeTag,
  Separator,
  Kana,
  Furigana,
  WordContainer
} from "@/components/sharedstyles";
import Cards from "@/components/cards";
import Error from "next/error";

const Home = (props : any) => {
   
  if (!props.sucess) return <p>Bad :c</p>

  console.log(props.data)
  const word : string  =  props.data.japanese[0].word;
  const furigana : string = props.data.japanese[0].reading;

  return (
    <Container>
      <Head>
        <title>Create Next App</title>
        <meta name="description" content="Generated by create next app" />
        <link rel="icon" href="/favicon.ico" />
      </Head>
      <Main>
        <WordContainer>
          <Furigana>
            {furigana}
          </Furigana>
          <Kana>
            <Title>
              {word}
            </Title>
          </Kana>
        </WordContainer>
        <Separator/>

        {/* <Description>
          Get started by editing
          <CodeTag>pages/index.tsx</CodeTag>
        </Description> */}

        {/* <Cards /> */}
      </Main>
    </Container>
  );
}

const isKanji = (char: string): boolean  => {
  // Regular expression for Japanese Kanji characters
  // (Unicode range: \u4e00-\u9faf)
  const kanjiRegex = /[\u4e00-\u9faf]/;
  return kanjiRegex.test(char);
}

interface WordResult extends JishoResult {
  kanjis : KanjiParseResult[];
}

interface KanjiReading {
  kanji: string;
  reading: string;
}

function separateKanjiReadings(word: string, reading: string): KanjiReading[] {
  const kanjiReadings: KanjiReading[] = [];
  const kanjiArray: string[] = Array.from(new Set(word.match(/[一-龯]/g))); // Extract unique kanji characters

  // Iterate over kanji characters in the word
  for (const kanji of kanjiArray) {
      // Find the index of the kanji in the word
      const index = word.indexOf(kanji);
      // Get the reading for this kanji
      const kanjiReading = reading.substr(index, kanji.length).trim();
      // Create object for kanji and its reading
      kanjiReadings.push({ kanji, reading: kanjiReading });
  }

  return kanjiReadings;
}


export async function getServerSideProps() {

  const jisho = new JishoAPI();

  try {

    const search_frase : string = "大臣";

    const res : JishoAPIResult = await jisho.searchForPhrase(search_frase);

    if (res.meta.status != 200) return; 

    // Try to find exact match for word
    
    const results : JishoResult[] = res.data;

    let exact_match : JishoResult | undefined;

    exact_match = results.find( result => {
      return result.slug === search_frase;
    })

    if (exact_match == undefined) return { props: { sucess: false } };

    // Create list of Kanjis in word
    const kanjis : string[] = exact_match?.slug
      .split("")
      .filter(character => isKanji(character));

    // Get aditional kanji info
    let kanji_results : KanjiParseResult[] = await Promise.all(kanjis.map( async (kanji) => {
      const kanji_res : KanjiParseResult = await jisho.searchForKanji(kanji);
      return kanji_res;
    }));


    // Create Kanji view (adding furigana)
    let view_kanji = kanji_results.map( (kanji_result, index) => {
      // const all_readings : string[] = [...kanji_result.kunyomi, ...kanji_result.onyomi];
      const kanji_reading = separateKanjiReadings(exact_match.slug, exact_match.japanese[0].reading)
      console.log(kanji_reading)
    });

    const word_result : WordResult = {
      ...exact_match,
      kanjis: kanji_results,
    }

    // const teste = 

    // console.log(word_result);


    return { props: { data: word_result, sucess: true } }
  } 
  catch (error : any) {
    console.log(error)
    return { props: { sucess: false } }
  }
}

export default Home;
